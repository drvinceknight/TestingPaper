@article{Forward2002,
abstract = {This paper highlights the results of a survey of software professionals. One of the goals of this survey was to uncover the perceived relevance (or lack thereof) of software documentation, and the tools and technologies used to maintain, verify and validate such documents. The survey results highlight the preferences for and aversions against software documentation tools. Participants agree that documentation tools should seek to better extract knowledge from core resources. These resources include the system's source code, test code and changes to both. Resulting technologies could then help reduce the effort required for documentation maintenance, something that is shown to rarely occur. Our data reports compelling evidence that software professionals value technologies that improve automation of the documentation process, as well as facilitating its maintenance.},
author = {Forward, Andrew and Lethbridge, Timothy C},
doi = {10.1145/585058.585065},
file = {:Users/vince/Dropbox/Mendeley/2002/2002 - Forward, Lethbridge - The relevance of software documentation, tools and technologies a survey.pdf:pdf},
isbn = {1581135947},
journal = {DocEng 02 Proceedings of the 2002 ACM symposium on Document engineering},
keywords = {documentation technologies,engineering,program comprehension,software,software documentation,software maintenance},
pages = {26--33},
title = {{The relevance of software documentation, tools and technologies: a survey}},
url = {http://portal.acm.org/citation.cfm?doid=585058.585065},
year = {2002}
}
@article{Lethbridge2003,
author = {Lethbridge, Timothy C and Singer, Janice and Forward, Andrew},
file = {:Users/vince/Dropbox/Mendeley/2003/2003 - Lethbridge, Singer, Forward - Use Documentation The State of the Practice Documentation.pdf:pdf},
journal = {Ieee Focus},
pages = {5},
title = {{Use Documentation : The State of the Practice Documentation}},
year = {2003}
}
@misc{Axelrod-Pythonprojectteam2015,
author = {Axelrod-Python project team},
title = {{Axelrod-Python v0.0.27}},
url = {http://axelrod-python.github.io/},
year = {2015}
}
@article{khmer2015,
 author = "Crusoe, Michael R. and Alameldin, Hussien F. and Awad, Sherine
and Bucher, Elmar and Caldwell, Adam and Cartwright, Reed and Charbonneau,
Amanda and Constantinides, Bede and Edvenson, Greg and Fay, Scott and Fenton,
Jacob and Fenzl, Thomas and Fish, Jordan and Garcia-Gutierrez, Leonor and
Garland, Phillip and Gluck, Jonathan and GonzÃ¡lez, IvÃ¡n and Guermond, Sarah
and Guo, Jiarong and Gupta, Aditi and Herr, Joshua R. and Howe, Adina and
Hyer, Alex and HÃ¤rpfer, Andreas and Irber, Luiz and Kidd, Rhys and Lin, David
and Lippi, Justin and Mansour, Tamer and McA'Nulty, Pamela and McDonald, Eric
and Mizzi, Jessica and Murray, Kevin D. and Nahum, Joshua R. and Nanlohy,
Kaben and Nederbragt, Alexander Johan and Ortiz-Zuazaga, Humberto and Ory,
Jeramia and Pell, Jason and Pepe-Ranney, Charles and Russ, Zachary N and
Schwarz, Erich and Scott, Camille and Seaman, Josiah and Sievert, Scott and
Simpson, Jared and Skennerton, Connor T. and Spencer, James and Srinivasan,
Ramakrishnan and Standage, Daniel and Stapleton, James A. and Stein, Joe and
Steinman, Susan R and Taylor, Benjamin and Trimble, Will and Wiencko, Heather
L. and Wright, Michael and Wyss, Brian and Zhang, Qingpeng and zyme, en and
Brown, C. Titus"
 title = "The khmer software package: enabling efficient nucleotide
sequence analysis",
 year = "2015",
 month = "08",
 publisher = "F1000",
 url = "http://dx.doi.org/10.12688/f1000research.6924.1"
}
@Book{ IEEE2008,
  title = "{IEEE Standard for Floating-Point Arithmetic (754-2008)}",
  author = {IEEE},
  publisher = {IEEE},
  year = {2008},
  annote = {ISBN: 978-0-7381-5753-5
Digital Object Identifier: 10.1109/IEEESTD.2008.4610935},
  keywords = {ARITH FLOAT STANDARD}
}

@article{Meyer2009a,
 author = {Meyer, Rob},
 title = {Wrangling the high-performance computer},
 journal = {Mechanical Engineering},
 issue_date = {February 2009},
 volume = {131},
 number = {2},
 month = {February},
 year = {2009},
 pages = {43--45},
}

@article{Runciman2008,
abstract = {This paper describes two Haskell libraries for property-based testing. Following the lead of QuickCheck (Claessen and Hughes 2000), these testing libraries SmallCheck and Lazy SmallCheck also use type-based generators to obtain test-sets of finite values for which properties are checked, and report any counter-examples found. But instead of using a sample of randomly generated values they test properties for all values up to some limiting depth, progressively increasing this limit. The paper explains the design and implementation of both libraries and evaluates them in comparison with each other and with QuickCheck.},
author = {Runciman, Colin},
doi = {http://doi.acm.org/10.1145/1411286.1411292},
file = {:Users/vince/Dropbox/Mendeley/2008/2008 - Runciman - SmallCheck and Lazy SmallCheck automatic exhaustive testing for small values.pdf:pdf},
isbn = {9781605580647},
issn = {15232867},
journal = {Technology},
keywords = {embedded language,ex-,haustive search,lazy evaluation,property-based testing,type classes},
number = {September},
pages = {37--48},
title = {{SmallCheck and Lazy SmallCheck automatic exhaustive testing for small values}},
url = {http://eprints.whiterose.ac.uk/68545/},
year = {2008}
}
@article{Yang2006,
abstract = {Storage systems such as file systems, databases, and RAID systems have a simple, basic contract: you give them data, they do not lose or corrupt it. Often they store the only copy, making its irrevocable loss almost arbitrarily bad. Unfortunately, their code is exceptionally hard to get right, since it must correctly recover from any crash at any program point, no matter how their state was smeared across volatile and persistent memory.$\backslash$n$\backslash$nThis paper describes EXPLODE, a system that makes it easy to systematically check real storage systems for errors. It takes user-written, potentially system-specific checkers and uses them to drive a storage system into tricky corner cases, including crash recovery errors. EXPLODE uses a novel adaptation of ideas from model checking, a comprehensive, heavy-weight formal verification technique, that makes its checking more systematic (and hopefully more effective) than a pure testing approach while being just as lightweight.$\backslash$n$\backslash$nEXPLODE is effective. It found serious bugs in a broad range of real storage systems (without requiring source code): three version control systems, Berkeley DB, an NFS implementation, ten file systems, a RAID system, and the popular VMware GSX virtual machine. We found bugs in every system we checked, 36 bugs in total, typically with little effort.},
author = {Yang, Junfeng and Sar, Can and Engler, Dawson},
file = {:Users/vince/Dropbox/Mendeley/2006/2006 - Yang, Sar, Engler - eXplode a Lightweight, General System for Finding Serious Storage System Errors.pdf:pdf},
isbn = {1-931971-47-1},
journal = {Osdi '06},
pages = {131--146},
title = {{eXplode: a Lightweight, General System for Finding Serious Storage System Errors}},
year = {2006}
}
@article{Arts2008,
abstract = {When creating software, data types are the basic bricks. Most of the time a programmer will use data types defined in library modules, therefore being tested by many users over many years. But sometimes, the appropriate data type is unavailable in the libraries and has to be constructed from scratch. In this way, new basic bricks are created, and potentially used in many products in the future. It pays off to test such data types thoroughly. This {\%} paper presents a structured methodology to follow when testing data types using Quviq QuickCheck, a tool for random testing against specifications. The validation process will be explained carefully, from the convenience of defining a model for the data type to be tested, to a strategy for better shrinking of failing test cases, and including the benefits of working with {\%} symbolic representations. The leading example in this paper is a data type implemented for a risk management information system, a commercial product developed in Erlang, that has been used on a daily basis for several years.},
author = {Arts, Thomas and Castro, Laura M and Hughes, John},
doi = {10.1145/1411273.1411275},
file = {:Users/vince/Dropbox/Mendeley/2008/2008 - Arts, Castro, Hughes - Testing Erlang data types with quviq quickcheck.pdf:pdf},
isbn = {9781605580654},
journal = {Proceedings of the 7th ACM SIGPLAN workshop on ERLANG},
keywords = {as a case study,datatypes,erlang,erlang data types using,in this paper we,present a method for,quickcheck,quviq quickcheck 1,validating user-defined,we},
pages = {1--8},
title = {{Testing Erlang data types with quviq quickcheck}},
year = {2008}
}
@article{Claessen2000,
abstract = {Quick Check is a tool which aids the Haskell programmer in formulating and testing properties of programs. Properties are described as Haskell functions, and can be automatically tested on random input, but it is also possible to define custom test data generators. We present a number of case studies, in which the tool was successfully used, and also point out some pitfalls to avoid. Random testing is especially suitable for functional programs because properties can be stated at a fine grain. When a function is built from separately tested components, then random testing suffices to obtain good coverage of the definition under test.},
author = {Claessen, Koen and Hughes, John},
doi = {10.1145/351240.351266},
file = {:Users/vince/Dropbox/Mendeley/2000/2000 - Claessen, Hughes - QuickCheck a lightweight tool for random testing of Haskell programs.pdf:pdf},
isbn = {1581132026},
issn = {03621340},
journal = {ACM Sigplan Notices},
pages = {268--279},
title = {{QuickCheck: a lightweight tool for random testing of Haskell programs}},
url = {http://portal.acm.org/citation.cfm?id=351266},
volume = {35},
year = {2000}
}
